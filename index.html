<!DOCTYPE html>
<html lang="id">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Retro Top-Down Car Game ‚Äî Final (5 lanes, spawn cooldown, buff 300m)</title>
  <style>
    :root{--w:400px;--h:600px}
    html,body{height:100%;margin:0;font-family:system-ui,Segoe UI,Roboto,"Helvetica Neue",Arial;background:#111;color:#ddd;display:flex;align-items:center;justify-content:center}
    .wrap{width:var(--w);height:var(--h);background:#222;border:12px solid #000;box-shadow:0 6px 30px rgba(0,0,0,.8);position:relative}
    canvas{display:block;background:#333;width:100%;height:100%}
    .ui{position:absolute;left:8px;top:8px;font-size:13px}
    .ui .fuel{margin-bottom:6px}
    .ui .text{color:#fff}
    .hint{position:absolute;left:0;right:0;bottom:8px;text-align:center;font-size:12px;color:#aaa}
    .overlay{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;pointer-events:none}
    .buff-overlay{position:absolute;inset:0;display:none;align-items:center;justify-content:center;pointer-events:auto;background:linear-gradient(rgba(0,0,0,0.6),rgba(0,0,0,0.6));z-index:10}
    .buff-board{display:flex;gap:12px;align-items:center}
    .card{width:110px;height:150px;background:#111;border:2px solid #666;border-radius:8px;box-shadow:0 4px 18px rgba(0,0,0,.8);display:flex;flex-direction:column;align-items:center;justify-content:center;transform:scale(.8);opacity:0;transition:transform .28s cubic-bezier(.2,.9,.2,1),opacity .28s;cursor:pointer}
    .card.show{transform:scale(1);opacity:1}
    .card .name{font-weight:700;margin-bottom:6px;text-align:center}
    .card .desc{font-size:11px;color:#ccc;padding:6px;text-align:center}
    .card.picked{animation:pickZoom .35s steps(4, end) forwards}
    @keyframes pickZoom{0%{transform:scale(1);filter:contrast(1)}40%{transform:scale(1.25);filter:contrast(1.2)}60%{transform:scale(1.1);filter:contrast(.9)}100%{transform:scale(0);opacity:0}}
    @keyframes retroFlicker{0%{opacity:1}20%{opacity:.4}40%{opacity:1}60%{opacity:.6}100%{opacity:1}}
    .active-buffs{position:absolute;right:8px;top:8px;display:flex;flex-direction:column;gap:8px;pointer-events:none}
    .buff-slot{background:rgba(0,0,0,0.4);border:1px solid #444;padding:6px 8px;border-radius:6px;display:flex;align-items:center;gap:8px;width:150px}
    .buff-icon{width:28px;height:28px;border-radius:4px;background:#222;display:inline-flex;align-items:center;justify-content:center;font-size:14px}
    .buff-info{flex:1;font-size:12px}
    .small{font-size:12px;color:#ccc}
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="game" width="400" height="600"></canvas>

    <div class="ui">
      <div class="fuel">
        <span class="text">Bensin</span>
        <div id="fuelBar" style="width:200px;height:10px;background:#222;margin-top:4px;border:2px solid #111;box-shadow:inset 0 0 6px rgba(0,0,0,.6)">
          <div id="fuelFill" style="height:100%;width:100%"></div>
        </div>
      </div>
      <div style="margin-top:6px"><span class="text">Skor: </span><span id="score">0</span> <span class="small"> | Jarak: </span><span id="distance">0</span>m</div>
    </div>

    <div class="active-buffs" id="activeBuffsUI"></div>
    <div class="overlay"><div id="message" style="color:#fff;font-size:26px;text-align:center;text-shadow:0 2px 6px rgba(0,0,0,.8)"></div></div>
    <div class="hint">Gunakan ‚Üê ‚Üí atau sentuh kiri/kanan untuk pindah. Ambil kotak kuning untuk mengisi bensin.</div>

    <div id="buffOverlay" class="buff-overlay"><div class="buff-board" id="buffBoard"></div></div>
  </div>

<script>
/* Minimal comments kept (‚â§5) */

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const W = canvas.width, H = canvas.height;

// player + world
const player = { baseW:36, baseH:56, w:36, h:56, x:(W-36)/2, y:H-90, color:'#ff3b3b', speed:4 };
let enemies = [], fuels = [], keys = {};
let fuel = 100, score = 0, distance = 0;
let running = true, gameOver = false, spawnTimer = 0, fuelTimer = 0, roadOffset = 0;

function rand(a,b){ return Math.random()*(b-a)+a; }

// lanes + road bounds
const LANE_COUNT = 5;
const ROAD_LEFT = 40;
const ROAD_WIDTH = W - 80;
const LANE_WIDTH = ROAD_WIDTH / LANE_COUNT;
const PLAYER_MIN_X = ROAD_LEFT + 6; // left bound for player
const PLAYER_MAX_X = ROAD_LEFT + ROAD_WIDTH - player.w - 6; // right bound
const MAX_PER_LANE = 4;
const MIN_SPAWN_GAP = 80; // px
const PER_LANE_COOLDOWN_MS = 1800; // ms
const BUFF_DISTANCE = 300; // every 300m now
const MAX_ENEMIES = 8;

let laneCooldowns = new Array(LANE_COUNT).fill(0);

// buff system
const allBuffs = [
  { id:'nitro', name:'Nitro', desc:'+50% speed', dur:5000, icon:'‚ö°' },
  { id:'fuel_saver', name:'Fuel Saver', desc:'-50% fuel use', dur:15000, icon:'‚õΩ' },
  { id:'ghost', name:'Ghost', desc:'Ignore collisions', dur:5000, icon:'üëª' },
  { id:'double_fuel', name:'Double Fuel', desc:'Fuel pickups x2', dur:12000, icon:'üîã' },
  { id:'magnet', name:'Magnet', desc:'Attract fuel', dur:10000, icon:'üß≤' },
  { id:'slowmo', name:'Slow', desc:'Slow enemies', dur:5000, icon:'üê¢' },
  { id:'shield', name:'Shield', desc:'Block 1 hit', dur:0, icon:'üõ°Ô∏è' },
  { id:'score2x', name:'2x Score', desc:'Double points', dur:10000, icon:'‚≠ê' },
  { id:'fuel_regen', name:'Regen', desc:'Gradual fuel', dur:8000, icon:'üå±' },
  { id:'shrink', name:'Shrink', desc:'Smaller hitbox', dur:8000, icon:'üîç' }
];
let activeBuffs = [];
let lastBuffDistance = 0;
let buffOverlay = document.getElementById('buffOverlay');
let buffBoard = document.getElementById('buffBoard');
let activeBuffsUI = document.getElementById('activeBuffsUI');

let lastShieldConsumedTime = -Infinity;
const SHIELD_COOLDOWN_MS = 350;

// input
window.addEventListener('keydown', e => keys[e.key] = true);
window.addEventListener('keyup', e => keys[e.key] = false);
canvas.addEventListener('touchstart', handleTouch); canvas.addEventListener('touchmove', handleTouch);
function handleTouch(e){
  e.preventDefault();
  const t = e.touches[0]; if(!t) return;
  const rect = canvas.getBoundingClientRect();
  const x = (t.clientX - rect.left) * (canvas.width / rect.width);
  keys['touch'] = x < W/2 ? 'left' : 'right';
}
canvas.addEventListener('touchend', ()=>{ keys['touch']=false; });
buffOverlay.addEventListener('click', e => e.stopPropagation());

// collision helper
function rectColl(a,b){ return a.x < b.x+b.w && a.x+a.w > b.x && a.y < b.y+b.h && a.y+a.h > b.y; }

// spawn enemy: per-lane cooldown + per-lane capacity + global cap
function spawnEnemy(){
  if(enemies.length >= MAX_ENEMIES) return;
  const now = Date.now();
  const w = 36, h = 56, spawnY = -h;
  const lanes = [];

  for(let lane=0; lane<LANE_COUNT; lane++){
    const laneEnemies = enemies.filter(e=>e.lane===lane);
    const count = laneEnemies.length;
    const nearestY = count ? Math.max(...laneEnemies.map(e=>e.y)) : -Infinity;
    lanes.push({ lane, count, nearestY });
  }
  // prefer less occupied lanes
  lanes.sort((a,b)=>a.count - b.count);

  let chosen = null;
  for(const info of lanes){
    if(info.count >= MAX_PER_LANE) continue;
    const cd = laneCooldowns[info.lane];
    if(now - cd < PER_LANE_COOLDOWN_MS) continue; // cooldown
    if(info.count === 0){ chosen = info.lane; break; }
    const gap = info.nearestY - spawnY;
    if(gap >= MIN_SPAWN_GAP){ chosen = info.lane; break; }
  }
  if(chosen === null){
    // try any lane with cooldown expired
    for(const info of lanes){
      if(info.count < MAX_PER_LANE && (now - laneCooldowns[info.lane]) >= PER_LANE_COOLDOWN_MS){ chosen = info.lane; break; }
    }
  }
  if(chosen === null) return; // skip this spawn

  const x = Math.round(ROAD_LEFT + LANE_WIDTH * chosen + (LANE_WIDTH - w)/2);
  const baseSpeed = rand(1.0,2.2);
  enemies.push({ x, y: spawnY, w, h, baseSpeed, speed: baseSpeed, lane: chosen });
  laneCooldowns[chosen] = now;
}

// spawn fuel with small cap
function spawnFuel(){
  if(fuels.length >= 6) return;
  const w = 30, h = 28;
  const lane = Math.floor(rand(0, LANE_COUNT));
  const x = Math.round(ROAD_LEFT + LANE_WIDTH * lane + (LANE_WIDTH - w)/2);
  fuels.push({ x, y:-h, w, h, speed: 2.2 });
}

// buff handling
function activateBuff(buff){
  const now = performance.now();
  const entry = { id: buff.id, expires: buff.dur>0 ? now + buff.dur : null, buff, data: {} };
  if(buff.id === 'shield') entry.data.count = 1;
  if(buff.id === 'shrink'){ player.w = Math.round(player.baseW * 0.8); player.h = Math.round(player.baseH * 0.8); }
  activeBuffs.push(entry);
}
function removeBuffIndex(idx){
  const b = activeBuffs[idx]; if(!b) return;
  if(b.id === 'shrink'){ player.w = player.baseW; player.h = player.baseH; }
  activeBuffs.splice(idx,1);
}
function applyBuffHousekeeping(){
  const now = performance.now();
  for(let i=activeBuffs.length-1;i>=0;i--){
    const b = activeBuffs[i];
    if(b.expires && b.expires <= now) removeBuffIndex(i);
  }
}
function isBuffActive(id){ return activeBuffs.some(b=>b.id===id); }

function showBuffChoices(){
  const pool = [...allBuffs], pick=[];
  for(let i=0;i<3;i++){ const idx=Math.floor(rand(0,pool.length)); pick.push(pool.splice(idx,1)[0]); }
  buffBoard.innerHTML = '';
  pick.forEach((b,i)=>{ const c=document.createElement('div'); c.className='card'; c.innerHTML=`<div class='name'>${b.name}</div><div class='desc'>${b.desc}</div>`; c.addEventListener('click',(e)=>{e.stopPropagation(); pickCard(c,b);}); buffBoard.appendChild(c); setTimeout(()=>c.classList.add('show'),80*i); });
  buffOverlay.style.display='flex'; running=false;
}
function pickCard(cardEl,buff){
  cardEl.classList.add('picked'); cardEl.style.animationTimingFunction='steps(4,end)'; buffBoard.style.animation='retroFlicker .28s linear';
  setTimeout(()=>{ buffOverlay.style.display='none'; buffBoard.style.animation=''; activateBuff(buff); running=true; updateActiveBuffsUI(); },360);
}
function updateActiveBuffsUI(){
  activeBuffsUI.innerHTML = ''; const now=performance.now();
  activeBuffs.forEach(b=>{ const el=document.createElement('div'); el.className='buff-slot'; const icon=document.createElement('div'); icon.className='buff-icon'; icon.textContent=b.buff.icon||'?'; const info=document.createElement('div'); info.className='buff-info'; const name=document.createElement('div'); name.textContent=b.buff.name; name.style.fontWeight='700'; const time=document.createElement('div'); time.style.fontSize='11px'; time.style.opacity='0.9'; const remaining=b.expires? Math.max(0,Math.ceil((b.expires-now)/1000))+'s':(b.data.count? 'x'+b.data.count:''); time.textContent=remaining; info.appendChild(name); info.appendChild(time); el.appendChild(icon); el.appendChild(info); activeBuffsUI.appendChild(el); });
}

// visuals
function drawShield(x,y,w,h,t){ const cx=x+w/2, cy=y+h/2, r=Math.max(w,h)*0.9+Math.sin(t/200)*4; ctx.save(); ctx.globalAlpha=0.22; ctx.strokeStyle='#7fd1ff'; ctx.lineWidth=3; ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.stroke(); ctx.restore(); }
function drawGhostTint(){ ctx.globalAlpha = 0.45; }
function drawMotionTrail(x,y,w,h,t){ ctx.save(); ctx.globalAlpha = 0.18; for(let i=1;i<=3;i++){ ctx.fillRect(x - i*6, y + i*6, w, h-10); } ctx.restore(); }
function drawStars(x,y,w,h,t){ ctx.save(); ctx.globalAlpha = 0.9; const cx=x+w/2, top=y-12-Math.abs(Math.sin(t/150))*6; ctx.fillStyle='#ffd700'; ctx.fillRect(cx-2, top, 4,4); ctx.fillRect(cx+8, top+2, 3,3); ctx.restore(); }

function update(dt){
  if(!running || gameOver) return;

  // player input + clamp to road
  const moveSpeed = player.speed * (isBuffActive('nitro')?1.5:1);
  if((keys['ArrowLeft']||keys['a']||keys['A']||keys['touch']==='left')) player.x -= moveSpeed;
  if((keys['ArrowRight']||keys['d']||keys['D']||keys['touch']==='right')) player.x += moveSpeed;
  if(player.x < PLAYER_MIN_X) player.x = PLAYER_MIN_X;
  if(player.x > PLAYER_MAX_X) player.x = PLAYER_MAX_X;

  // distance & fuel
  const forwardSpeed = 2.4; distance += forwardSpeed * dt * 0.01; document.getElementById('distance').innerText = Math.floor(distance);
  let consumption = 0.02; if(isBuffActive('fuel_saver')) consumption *= 0.5; if(isBuffActive('nitro')) consumption *= 1.12; fuel -= consumption;
  if(isBuffActive('fuel_regen')) fuel = Math.min(100, fuel + 0.02 * dt/16);
  if(fuel<=0){ fuel=0; running=false; showMessage('KEHABISAN BENSIN'); }

  // spawns
  spawnTimer += dt; const baseInterval = 700 - Math.min(distance,400); const spawnInterval = baseInterval * 1.3;
  if(spawnTimer > spawnInterval){ spawnTimer = 0; spawnEnemy(); }
  fuelTimer += dt; if(fuelTimer > 3500){ fuelTimer = 0; spawnFuel(); }

  // move enemies and anti-collision (per-lane), then limit overlap
  for(const e of enemies) e.y += e.speed * (isBuffActive('slowmo')?0.5:1);

  const SAFE_DISTANCE = 36;
  for(let lane=0; lane<LANE_COUNT; lane++){
    const laneEnemies = enemies.filter(e=>e.lane===lane).sort((a,b)=>b.y - a.y);
    for(let i=0;i<laneEnemies.length-1;i++){
      const front = laneEnemies[i];
      const back  = laneEnemies[i+1];
      const gap = front.y - (back.y + back.h);
      if(gap < SAFE_DISTANCE){
        const target = Math.min(front.speed, back.baseSpeed);
        back.speed += (target - back.speed) * 0.18;
        const desiredBackY = front.y - front.h - SAFE_DISTANCE;
        if(back.y > desiredBackY) back.y = desiredBackY;
      } else {
        back.speed += (back.baseSpeed - back.speed) * 0.02;
      }
    }
  }

  enemies = enemies.filter(e=>e.y < H + 120);

  // fuels & magnet
  for(let f of fuels){
    if(isBuffActive('magnet')){
      const dx = player.x + player.w/2 - (f.x + f.w/2);
      const dy = player.y + player.h/2 - (f.y + f.h/2);
      const dist = Math.hypot(dx,dy);
      if(dist < 160){ f.x += dx / dist * 2.5; f.y += dy / dist * 2.5; } else f.y += f.speed;
    } else f.y += f.speed;
  }
  fuels = fuels.filter(f=>f.y < H + 60);

  // collisions
  const now = performance.now();
  const collidedIdxs = [];
  for(let i=0;i<enemies.length;i++){ const e=enemies[i]; if(e.y > player.y - 120 && e.y < player.y + 120 && rectColl(player,e)) collidedIdxs.push(i); }
  if(collidedIdxs.length>0){
    if(isBuffActive('ghost')) {
      // ignore
    } else {
      const shieldIdx = activeBuffs.findIndex(b=>b.id==='shield');
      if(shieldIdx>=0 && activeBuffs[shieldIdx].data.count>0 && (now - lastShieldConsumedTime) > SHIELD_COOLDOWN_MS){
        activeBuffs[shieldIdx].data.count--;
        if(activeBuffs[shieldIdx].data.count<=0) removeBuffIndex(shieldIdx);
        enemies.splice(collidedIdxs[0],1);
        lastShieldConsumedTime = now;
      } else {
        gameOver = true; running = false; showMessage('GAME OVER');
      }
    }
  }

  // fuel pickups
  for(let i=fuels.length-1;i>=0;i--){ if(rectColl(player, fuels[i])){ const amount = isBuffActive('double_fuel')?60:30; fuel = Math.min(100, fuel+amount); fuels.splice(i,1); } }

  score += dt*0.01*(isBuffActive('score2x')?2:1);
  applyBuffHousekeeping(); updateActiveBuffsUI();

  if(distance - lastBuffDistance >= BUFF_DISTANCE){ lastBuffDistance += BUFF_DISTANCE; showBuffChoices(); }

  roadOffset += 200*dt/1000; if(roadOffset>40) roadOffset-=40;
}

function draw(){
  const t = performance.now();
  ctx.clearRect(0,0,W,H);

  // road + guide lines
  ctx.fillStyle = '#2a2a2a'; ctx.fillRect(0,0,W,H);
  ctx.fillStyle = '#111'; ctx.fillRect(0,0,40,H); ctx.fillRect(W-40,0,40,H);
  ctx.fillStyle = '#222'; ctx.fillRect(40,0,W-80,H);
  ctx.save(); ctx.translate(0,roadOffset); ctx.fillStyle='#d9d9d9'; for(let y=-60;y<H+80;y+=40) ctx.fillRect(W/2-6, y, 12, 22); ctx.restore();
  ctx.strokeStyle = 'rgba(255,255,255,0.03)'; ctx.lineWidth = 1;
  for(let i=1;i<LANE_COUNT;i++){ const lx = ROAD_LEFT + i*LANE_WIDTH; ctx.beginPath(); ctx.moveTo(lx,0); ctx.lineTo(lx,H); ctx.stroke(); }

  // enemies
  for(const e of enemies) drawCar(e.x, e.y, e.w, e.h, '#3b82f6');

  // fuels
  for(const f of fuels) drawFuelBox(f.x, f.y, f.w, f.h);

  // player effects
  ctx.save();
  if(isBuffActive('ghost')){ drawGhostTint(); const flick = 0.65 + Math.sin(t/120)/6; ctx.globalAlpha = flick; }
  if(isBuffActive('nitro')) drawMotionTrail(player.x, player.y, player.w, player.h, t);
  drawCar(player.x, player.y, player.w, player.h, player.color);
  ctx.restore();

  if(isBuffActive('shield')) drawShield(player.x, player.y, player.w, player.h, t);
  if(isBuffActive('score2x')) drawStars(player.x, player.y, player.w, player.h, t);

  document.getElementById('score').innerText = Math.floor(score);
  const fill = document.getElementById('fuelFill'); fill.style.width = Math.max(0, fuel) * 2 + 'px'; fill.style.background = fuel>40? '#39b54a' : fuel>15? '#f0a500' : '#ff3b3b';
}

function drawCar(x,y,w,h,color){
  ctx.fillStyle = '#000'; ctx.fillRect(x+2,y+2,w,h);
  ctx.fillStyle = color; ctx.fillRect(x,y,w,h-10);
  ctx.fillStyle = 'rgba(255,255,255,0.6)'; ctx.fillRect(x+6,y+8,w-12,12);
  ctx.fillStyle = '#111'; ctx.fillRect(x+4,y+h-8,8,6); ctx.fillRect(x+w-12,y+h-8,8,6);
}
function drawFuelBox(x,y,w,h){ ctx.fillStyle='#b58300'; ctx.fillRect(x,y,w,h); ctx.fillStyle='#fff'; ctx.fillRect(x+6,y+6,w-12,h-12); ctx.fillStyle='#b58300'; ctx.fillRect(x+9,y+9,w-18,h-18); }

let last = performance.now();
function frame(now){ const dt = Math.max(8, now - last); last = now; update(dt); draw(); requestAnimationFrame(frame); }
function showMessage(txt){ document.getElementById('message').textContent = txt; }
requestAnimationFrame(frame);

// restart: reset everything
window.addEventListener('click', ()=>{
  if(buffOverlay.style.display === 'flex') return;
  if(!gameOver && running) return;
  enemies = []; fuels = []; fuel = 100; score = 0; distance = 0; running = true; gameOver = false; spawnTimer=0; fuelTimer=0; lastBuffDistance=0; activeBuffs=[]; laneCooldowns = new Array(LANE_COUNT).fill(0); updateActiveBuffsUI(); lastShieldConsumedTime = -Infinity; document.getElementById('message').textContent = '';
});
</script>
</body>
</html>
